[{"title":"王爽《汇编语言》lab17","path":"/2023/10/21/汇编语言/lab17/","content":"题目 安装一个新的int7中断例程，实现通过逻辑扇区号对软盘进行读写。 遇到的问题以及解决方法 在我的dosbox下，不能对软盘进行读写，也就是mov dl,0不行，但可以对硬盘进行读写，也就是mov dl,80h可以。 收获 要注意栈push和pop的时机，比如对al和ah设置好内容了之后，再pop ax会使得设置无效。需要调整顺序。 代码 install.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset write2disk mov ax,0 mov es,ax mov di,200h mov cx,offset write2diskEnd - offset write2disk cld rep movsb cli mov es:[7ch*4],200h mov es:[7ch*4+2],0 sti mov ax,4c00h int 21hwrite2disk: ; dx 是传入的逻辑扇区号，es:bx为操作内存 cmp ah,1 ja sret push bx push ax mov bx,1440 mov ax,dx mov dx,0 div bx ; 得到 int(逻辑扇区号/1440) 存放在ax内，得到 rem(逻辑扇区号/1440) 存放在dx内 mov si,ax mov bh,0 mov bl,18 mov ax,dx div bl ; 得到 int(rem(逻辑扇区号/1440)/18) 存放在al内，得到 rem(rem(逻辑扇区号/1440)/18) 存放在ah内 ; 设置参数 mov dx,si mov dh,dl ; 面号 mov ch,al mov cl,ah inc cl pop ax pop bx mov al,1 mov dl,80h add ah,2 int 13hsret: iretwrite2diskEnd: nopcode endsend start test.asm 123456789101112131415assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov bx,0 mov ah,0 mov dx,0 int 7ch mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab16","path":"/2023/10/20/汇编语言/lab16/","content":"要求 安装一个新的int7ch中断例程，为显示输出提供如下功能子程序。 (1)清屏： (2)设置前景色； (3)设置背景色： (4)向上滚动一行。 入口参数说明如下。 (1)用ah寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行； (2)对于1、2号功能，用al传送颜色值，(al)∈{0,1,2,3,4,5,6,7}。 需要思考的问题 安装好程序之后，如何寻址到对应的子程序？ 解答：当安装好程序之后，test.asm中的int 7ch会调用该中断程序，那么此时CS:IP设置为0000:0200 执行到call word ptr cs:[202h+bx]时，会寻址到 sub1 - setScreen + 200H，也就是sub1程序。 但是call word ptr table[bx]并不能正确寻址到sub1程序，并且table dw sub1 - setScreen + 200H不能写成table dw sub1， 本人猜测是因为该程序放在0:200处，不是在定义的代码段内，所以并不能只通过 table 和 sub1 正确寻址，需要通过位移。 （jmp short set 的机器码也是包含位移） 代码 install.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,200h mov ax,cs mov ds,ax mov si,offset setScreen mov cx,offset setScreenEnd - offset setScreen cld rep movsb mov es:[7ch*4],200h mov es:[7ch*4+2],0 ; test ; mov ah,3 ; mov al,4 ; int 7ch mov ax,4c00h int 21hsetScreen: jmp short set table dw sub1 - setScreen + 200H, sub2 - setScreen + 200H, sub3 - setScreen + 200H, sub4 - setScreen + 200H set: push bx cmp ah,3 ja sret mov bl,ah mov bh,0 add bx,bx call word ptr cs:[202h+bx] ; call word ptr table[bx] sret: pop bx iretsub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000sub1s: mov byte ptr es:[bx],&#x27; &#x27; add bx,2 loop sub1s pop es pop cx pop bx retsub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000sub2s: and byte ptr es:[bx],11111000B or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx retsub3: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cl,4 shl al,cl mov cx,2000sub3s: and byte ptr es:[bx],10001111B or es:[bx],al add bx,2 loop sub3s pop es pop cx pop bx retsub4: push cx push si push di push es push ds mov si,0b800h mov ds,si mov es,si mov si,160 mov di,0 cld mov cx,24sub4s: push cx mov cx,160 rep movsb pop cx loop sub4s mov cx,80 mov si,0sub4s1: mov byte ptr [160*24+si],&#x27; &#x27; add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx retsetScreenEnd: nopcode endsend start test.asm 1234567891011assume cs:codecode segmentstart: mov ah,1 mov al,2 int 7ch mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab15","path":"/2023/10/20/汇编语言/lab15/","content":"要求 安装一个新的int 9中断例程，功能：在DOS下，按下“A”键后，除非不再松开，如果松开，就显示满屏幕的“A”,其他的键照常处理。 代码 install.asm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset int9 mov ax,0 mov es,ax mov di,204H mov cx,offset int9end-offset int9 cld rep movsb ; 把原int9程序的入口放在 0:200 ~ 0:203 中 mov ax,es:[9*4] mov es:[200H],ax mov ax,es:[9*4+2] mov es:[202H],ax ; 把现int9程序的入口放在 0:9*4 ~ 0:9*4+3 中，把int9程序放在以 0:204H 开始的地址中 mov word ptr es:[9*4],204H mov word ptr es:[9*4+2],0 mov ax,4c00h int 21hint9: push ax pushf call dword ptr cs:[200H] ;调用BIOS的int9中断例程，处理其他硬件细节 in al,60h cmp al,9EH jne int9retshowAllScreenA: mov ax,0b800h mov es,ax mov bx,0 mov cx,2000 s2: mov byte ptr es:[bx],&#x27;A&#x27; add bx,2 loop s2int9ret: pop ax iretint9end: nop code endsend start test.asm 12345678910111213141516171819202122assume cs:codecode segmentstart:delay: mov dx,100 mov ax,0s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1mov ax,4c00hint 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab14","path":"/2023/10/19/汇编语言/lab14/","content":"读取BIOS RAM中的内容。写入到显存内 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667assume cs:codedata segment db 9,8,7,4,2,0data endscode segmentstart: mov ax,data mov ds,ax mov dx,0b800H mov es,dx mov cx,6 mov si,0 mov di,160*0+2*0s: mov al,[si] out 70H,al in al,71H push cx mov ah,al mov cl,4 shr ah,cl pop cx and al,00001111B add ah,30H add al,30H call show add di,4 cmp si,0 je showSlash cmp si,1 je showSlash cmp si,2 je showSpace cmp si,3 je showColon cmp si,4 je showColonback: add di,2 inc si loop s mov ax,4c00h int 21hshow: mov byte ptr es:[di],ah mov byte ptr es:[di+2],al retshowSlash: mov byte ptr es:[di],47 jmp backshowSpace: mov byte ptr es:[di],0 jmp backshowColon: mov byte ptr es:[di],58 jmp backcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab13","path":"/2023/10/19/汇编语言/lab13/","content":"(1)编写并安装int 7ch中断例程，功能为显示一个用0结束的字符串 中断例程安装在0:200处。 参数：(dh)=行号，(dl)=列号，(cl)=颜色，ds:si指向字符串首地址。 install.asm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,200H mov ax,cs mov ds,ax mov si,offset showStr mov cx,offset showStrEnd-offset showStr cld rep movsb mov ax,0 mov es,ax mov word ptr es:[7cH*4],200h mov word ptr es:[7cH*4+2],0 mov ax,4c00h int 21h; -------; showStr是在对应的行列显示字符; -------showStr: mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax ;di为计算出来的偏移地址 mov bl,cl mov cx,0 s: mov cl,[si] jcxz ok mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 inc si jmp short s ok: iretshowStrEnd: nopcode endsend start test.asm 1234567891011121314151617181920assume cs:codedata segment db &quot;welcome to masm!&quot;, 0data endscode segmentstart: mov dh,10 ;行号 mov dl,10 ;列号 mov cl,2 mov ax,data mov ds,ax mov si,0 int 7ch mov ax,4c00h int 21hcode endsend start (2)编写并安装int7ch中断例程，功能为完成loop指令的功能 参数：(cx)=循环次数，(bx)=位移 在屏幕中间显示80个'!' install.asm 12345678910111213141516171819202122232425262728293031323334assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,200h mov ax,cs mov ds,ax mov si,offset emuLoop mov cx,offset emuLoopEnd-emuLoop cld rep movsb mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21hemuLoop: jcxz ok pop ax add ax,bx push ax dec cx ok: iretemuLoopEnd: nopcode endsend start test.asm 12345678910111213141516171819assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s-offset se mov cx,80s: mov byte ptr es:[di],&#x27;!&#x27; add di,2 int 7chse: nop mov ax,4c00h int 21hcode endsend start (3)下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。 1234567891011121314151617181920212223242526272829303132assume cs:codecode segment s1: db &#x27;Good,better,best,&#x27;, &#x27;$&#x27; s2: db &#x27;Never let it rest,&#x27;, &#x27;$&#x27; s3: db &#x27;Till good is better,&#x27;, &#x27;$&#x27; s4: db &#x27;And better,best.&#x27;, &#x27;$&#x27; s: dw offset s1,offset s2,offset s3,offset s4 row:db 2,4,6,8start: mov ax,cs mov ds,ax mov bx,offset s mov si,offset row mov cx,4ok: mov bh,0 mov dh,[si] mov dl,0 mov ah,2 int 10h ;设置光标位置 mov dx,[bx] mov ah,9 int 21h ;显示 ds:dx 开始的字符，到 $ 停止。 inc si add bx,2 loop ok mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab12","path":"/2023/10/15/汇编语言/lab12/","content":"实验要求：编写0号中断的处理程序，使得在除法溢出发生时，在屏幕中间显示字符串\"divede error\"，然后返回到DOS 主要考察 CPU是如何执行内中断的？ 简单来讲，CPU会根据中断信息获取中断类型码N，然后在中断向量表中根据 N 计算中断程序的入口地址，即 \\((IP) = (N*4), (CS) = (N*4+2)\\), 设置好CS:IP，也就是执行代码的位置, 开始执行即可。 如何设计代码？ 将中断程序的代码放入0000:0200 ~ 0000:02FF中，之后在中断向量表中设置好中断程序的入口地址即可。 &gt; 除法溢出的中断类型码是 0 代码 install.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051assume cs:codecode segment start: mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov ax,cs mov ds,ax mov si, offset do0 ;设置ds:si指向原地址 mov cx, offset do0end-offset do0 cld rep movsb mov ax,0 mov es,ax mov word ptr es:[0], 200H mov word ptr es:[2], 0H mov ax,4c00h int 21hdo0: jmp short do0start db &quot;divide error!&quot; do0start: mov ax,cs mov ds,ax mov si,0202h ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,160*0+2*0 ;设置es:di指向显存空间的中间位置 mov cx,0dh ;设置字符串长度s: mov al, ds:[si] mov ah, 2 ;设置为绿色 mov es:[di], ax inc si add di,2 loop s iretdo0end: nopcode endsend start test.asm 123456789assume cs:codecode segmentstart: int 0h mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》 lab11","path":"/2023/10/11/汇编语言/lab11/","content":"主要考察了cmp指令和je等条件转移指令的应用。 1234567891011121314151617181920212223242526272829303132assume cs:codesgdatasg segment db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;, 0datasg endscodesg segmentbegin: mov ax,datasg mov ds,ax call lettercok: mov ax,4c00h int 21hletterc: mov si,0 mov cx,0 s: mov al,[si] mov cl,al jcxz ok cmp al,97 jb exit cmp al,122 ja exit and al,11011111B mov [si],al exit: inc si jmp short scodesg endsend begin","tags":["汇编语言"]},{"title":"王爽《汇编语言》课程设计1","path":"/2023/10/08/汇编语言/课程设计1/","content":"实验要求：显示图片所示的内容 瑕疵以及解决方法 瑕疵：显示数据的时候最后一行往往不能正常显示。 解决方法：多添加了一行无用数据，使得题目所给数据能够正常显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200; 不知道为什么显示最后一行的时候会出错, 所以我多加了一行数据assume cs:codesgdata segmentdb&#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;db&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;db&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;,&#x27;0000&#x27;;以上是表示21年的21个字符串dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000,0 ;以上是表示21年公司总收入的21个dword型数据dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226dw 11542,14430,15257,17800,1;以上是表示21年公司雇员人数的21个word型数据data ends;将数据放到一张表里面table segmentdb 22 dup(&#x27;year summ ne ??&#x27;)table ends; 用来临时存放倒序的数digit segment db 32 dup(0)digit endsstacksg segment dw 8 dup (0)stacksg endscodesg segmentstart: mov ax,stacksg mov ss,ax mov sp,32 mov ax,table mov ds,ax\tmov ax,data\tmov es,ax\tmov si,0\tmov di,88\tmov bp,176\tmov bx,0\tmov cx,22 call dtb ; 经过测试，能成功将数据显示到table段中！ call far ptr vis_number mov ax,4c00h int 21hdtb: ; dtb将数据都放在table里面 s1: mov ax, es:[si] ;利用ax作为中转站 mov [bx+0], ax mov ax, es:[si+2] mov [bx+2], ax mov byte ptr [bx+4], 20h mov ax, es:[di] mov [bx+5], ax mov ax, es:[di+2] mov [bx+7], ax mov byte ptr [bx+9], 20h mov ax, es:[bp] mov [bx+10], ax mov byte ptr [bx+12], 20h mov ax, [bx+5] mov dx, [bx+7] div word ptr [bx+10] mov [bx+13], ax mov byte ptr [bx+15], 20h add bx,16 add si,4 add di,4 add bp,2 loop s1 retvis_number: mov bx,0B800H mov es,bx mov cx,22 mov si,0 ; ds:si 指向table mov di,0 ; es:di 指向显存位置 sr: push cx call far ptr paint ;把这一行都变为空白 mov cx,4 mov bp,cx s4: mov al,[si] mov es:[di],al inc si add di,2 loop s4 call far ptr set_begin inc si mov ax,[si] mov dx,[si+2] call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,5 mov ax,[si] mov dx,0 call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,3 mov ax,[si] mov dx,0 call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,3 add di,80 pop cx loop sr retfpaint: mov cx,40 s2: mov es:[di],0 mov es:[di+1],7 add di,2 loop s2 sub di,80 retfdtoc: pop bx ; dtoc 的 ip pop cx ; dtoc 的 cs push si push ds push di push cx push bx mov bx,digit mov ds,bx mov di,0 mov bp,0 s: mov cx,10 mov bx,ax ; bx存放L(低16位) mov ax,dx mov dx,0 div cx ; int(H/N)在ax中，rem(H/N)在dx中 mov si,ax ; si存放int(H/N) mov ax,bx div cx ; 余数在dx中 add dl,30H mov [di],dl mov cx,ax inc bp add cx,si ; 算商是否为0，(cx) = (si) + (ax) jcxz ps ;当商是0的时候退出 inc di mov dx,si jmp s ps: retfshow_str: mov cx,bp mov ax,bp dec bp mov si,bp inc bp s5: mov al,[si] mov es:[di],al dec si add di,2 loop s5 retfset_begin: sub di,bp sub di,bp add di,20 retfcodesg endsend start","tags":["汇编语言"]},{"title":"博客搭建","path":"/2023/10/06/博客搭建/","content":"博客搭建 对博客的优化 渲染latex","tags":["博客搭建"]},{"title":"王爽《汇编语言》lab10","path":"/2023/10/06/汇编语言/lab10/","content":"往显存里面写东西，使得显示器能立马显示所写的内容 下面是lab10的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103assume cs:codedata segment db 10 dup (0)data endscode segmentstart: ; test for subprogram 1 ; mov dh,13 ; mov dl,0 ; mov cl,2 ; mov ax,data ; mov ds,ax ; mov si,0 ; call show_str ; test for subprogram 2 ; mov ax,4240H ; mov dx,000FH ; mov cx,0AH ; call divdw ;test for subprogram 3 mov ax,12466 mov bx,data mov ds,bx mov si,0 mov bp,0 ;用来存放有几位 call dtoc ok2:mov dh,13 mov dl,0 mov cl,2 mov si,0 call show_str2 ok: mov ax,4c00h int 21hshow_str: mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax mov bl,cl mov cx,0 s: mov cl,[si] jcxz ok mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 inc si jmp short sshow_str2: ;搭配dtoc使用，实现反向输出 mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax mov bl,cl mov cx,bp dec bp mov si,bp s2: mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 dec si dec cx jcxz ok jmp short s2 dtoc: mov bx,10 mov dx,0 ;不写这句话程序运行不了，应该是后面用到了dl，所以需要将dx先置0 s1: div bx add dl,30H ;dl存放余数 mov [si],dl inc bp mov dl,0 mov cx,ax jcxz ok2 inc si jmp short s1divdw: mov bx,ax ;bx存放L mov ax,dx mov dx,0 div cx ;得到 int(H/N)在ax中 和 rem(H/N)在dx中 mov si,ax ;si存放int(H/N) mov ax,bx div cx mov dx,si retcode endsend start","tags":["汇编语言"]},{"title":"CSAPP_datalab","path":"/2023/09/23/CSAPP/lab1/","content":"自己本人只能做出30%，剩下的部分都是借鉴别人的代码而写的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211//1/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~(~x&amp;~y)&amp;~(x&amp;y);&#125;/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return (1&lt;&lt;31);&#125;//2/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; return !(~(x+1)^x)&amp;!!(x+1);&#125;/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int mask = 0xAA + ((0xAA)&lt;&lt;8); mask = mask + (mask&lt;&lt;16); return !((mask&amp;x)^mask);&#125;/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x + 1;&#125;//3/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; int a = !(x&gt;&gt;4 ^ 0x3); int na = ~0xA + 1; int x_b4 = x &amp; 0xF; int b = !!((x_b4 + na) &amp; 0x8000); return a &amp; b;&#125;/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; x = !!x; //x!=0 -&gt; 1 x ==0 -&gt; 0 x = ~x + 1; return (x&amp;y)|(~x&amp;z);&#125;/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int a = (x &gt;&gt; 31)&amp;0x1; int b = (y &gt;&gt; 31)&amp;0x1; int flag1 = (a&amp;~b); //a- b+ int flag2 = (~a&amp;b); //a+ b- int minus = (y + (~x+1)) &gt;&gt; 31; //x&lt;=y &lt;-&gt; minus=0 return flag1 | (!flag2 &amp; !minus);&#125;//4/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; return ((x|(~x+1))&gt;&gt;31)+1;&#125;/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) &#123; int b16, b8, b4, b2, b1, b0; int flag = x&gt;&gt;31; x = (~flag&amp;x)|(flag&amp;~x); //x若为负数，则取反 b16 = !!(x&gt;&gt;16)&lt;&lt;4; x &gt;&gt;= b16; b8 = !!(x&gt;&gt;8)&lt;&lt;3; x &gt;&gt;= b8; b4 = !!(x&gt;&gt;4)&lt;&lt;2; x &gt;&gt;= b4; b2 = !!(x&gt;&gt;2)&lt;&lt;1; x &gt;&gt;= b2; b1 = !!(x&gt;&gt;1); x &gt;&gt;= b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1;&#125;//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) &#123; int exp = (0x7f800000 &amp; uf)&gt;&gt;23; int sign = uf &amp; (1&lt;&lt;31); if(exp == 255) return uf; if(exp == 0) return (uf&lt;&lt;1)|sign; exp++; if(exp==255) return 0x7f800000|(uf&amp;0x807fffff); return (exp&lt;&lt;23)|(uf&amp;0x807fffff);&#125;/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) &#123; unsigned exp = (0x7f800000 &amp; uf)&gt;&gt;23; int sign = (uf&gt;&gt;31)&amp;0x1; unsigned frac = uf&amp;0x7fffff; int E = exp - 127; if(E &lt; 0) return 0; if(E &gt;= 31) return 0x80000000u; frac |= 1&lt;&lt;23; if(E &lt; 23) frac &gt;&gt;= (23-E); else frac &lt;&lt;= (E-23); if(sign) return -frac; else return frac;&#125;/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) &#123; if(x&gt;127) return (0xff)&lt;&lt;23; if(x&lt;-149) return 0; if(x&gt;=-126)&#123; int exp = x + 127; return (exp&lt;&lt;23); &#125; else&#123; int t = x + 149; return (1&lt;&lt;t); &#125; return 2;&#125;","tags":["CSAPP"]}]