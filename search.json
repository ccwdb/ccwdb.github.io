[{"title":"王爽《汇编语言》课程设计1","path":"/2023/10/08/汇编语言/课程设计1/","content":"花了大约两天的时间写完了课程设计1有些瑕疵，比如显示数据的时候最后一行往往不能正常显示。于是我多添加了一行无用数据，使得题目所给数据能够正常显示。如有大佬指点，万分感谢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200; 不知道为什么显示最后一行的时候会出错, 所以我多加了一行数据assume cs:codesgdata segmentdb&#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;db&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;db&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;,&#x27;0000&#x27;;以上是表示21年的21个字符串dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000,0 ;以上是表示21年公司总收入的21个dword型数据dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226dw 11542,14430,15257,17800,1;以上是表示21年公司雇员人数的21个word型数据data ends;将数据放到一张表里面table segmentdb 22 dup(&#x27;year summ ne ??&#x27;)table ends; 用来临时存放倒序的数digit segment db 32 dup(0)digit endsstacksg segment dw 8 dup (0)stacksg endscodesg segmentstart: mov ax,stacksg mov ss,ax mov sp,32 mov ax,table mov ds,ax\tmov ax,data\tmov es,ax\tmov si,0\tmov di,88\tmov bp,176\tmov bx,0\tmov cx,22 call dtb ; 经过测试，能成功将数据显示到table段中！ call far ptr vis_number mov ax,4c00h int 21hdtb: ; dtb将数据都放在table里面 s1: mov ax, es:[si] ;利用ax作为中转站 mov [bx+0], ax mov ax, es:[si+2] mov [bx+2], ax mov byte ptr [bx+4], 20h mov ax, es:[di] mov [bx+5], ax mov ax, es:[di+2] mov [bx+7], ax mov byte ptr [bx+9], 20h mov ax, es:[bp] mov [bx+10], ax mov byte ptr [bx+12], 20h mov ax, [bx+5] mov dx, [bx+7] div word ptr [bx+10] mov [bx+13], ax mov byte ptr [bx+15], 20h add bx,16 add si,4 add di,4 add bp,2 loop s1 retvis_number: mov bx,0B800H mov es,bx mov cx,22 mov si,0 ; ds:si 指向table mov di,0 ; es:di 指向显存位置 sr: push cx call far ptr paint ;把这一行都变为空白 mov cx,4 mov bp,cx s4: mov al,[si] mov es:[di],al inc si add di,2 loop s4 call far ptr set_begin inc si mov ax,[si] mov dx,[si+2] call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,5 mov ax,[si] mov dx,0 call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,3 mov ax,[si] mov dx,0 call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,3 add di,80 pop cx loop sr retfpaint: mov cx,40 s2: mov es:[di],0 mov es:[di+1],7 add di,2 loop s2 sub di,80 retfdtoc: pop bx ; dtoc 的 ip pop cx ; dtoc 的 cs push si push ds push di push cx push bx mov bx,digit mov ds,bx mov di,0 mov bp,0 s: mov cx,10 mov bx,ax ; bx存放L(低16位) mov ax,dx mov dx,0 div cx ; int(H/N)在ax中，rem(H/N)在dx中 mov si,ax ; si存放int(H/N) mov ax,bx div cx ; 余数在dx中 add dl,30H mov [di],dl mov cx,ax inc bp add cx,si ; 算商是否为0，(cx) = (si) + (ax) jcxz ps ;当商是0的时候退出 inc di mov dx,si jmp s ps: retfshow_str: mov cx,bp mov ax,bp dec bp mov si,bp inc bp s5: mov al,[si] mov es:[di],al dec si add di,2 loop s5 retfset_begin: sub di,bp sub di,bp add di,20 retfcodesg endsend start","tags":["汇编语言"],"categories":["汇编语言","lab以及课程设计"]},{"title":"王爽《汇编语言》lab10","path":"/2023/10/06/汇编语言/lab10/","content":"往显存里面写东西，使得显示器能立马显示所写的内容 下面是lab10的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103assume cs:codedata segment db 10 dup (0)data endscode segmentstart: ; test for subprogram 1 ; mov dh,13 ; mov dl,0 ; mov cl,2 ; mov ax,data ; mov ds,ax ; mov si,0 ; call show_str ; test for subprogram 2 ; mov ax,4240H ; mov dx,000FH ; mov cx,0AH ; call divdw ;test for subprogram 3 mov ax,12466 mov bx,data mov ds,bx mov si,0 mov bp,0 ;用来存放有几位 call dtoc ok2:mov dh,13 mov dl,0 mov cl,2 mov si,0 call show_str2 ok: mov ax,4c00h int 21hshow_str: mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax mov bl,cl mov cx,0 s: mov cl,[si] jcxz ok mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 inc si jmp short sshow_str2: ;搭配dtoc使用，实现反向输出 mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax mov bl,cl mov cx,bp dec bp mov si,bp s2: mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 dec si dec cx jcxz ok jmp short s2 dtoc: mov bx,10 mov dx,0 ;不写这句话程序运行不了，应该是后面用到了dl，所以需要将dx先置0 s1: div bx add dl,30H ;dl存放余数 mov [si],dl inc bp mov dl,0 mov cx,ax jcxz ok2 inc si jmp short s1divdw: mov bx,ax ;bx存放L mov ax,dx mov dx,0 div cx ;得到 int(H/N)在ax中 和 rem(H/N)在dx中 mov si,ax ;si存放int(H/N) mov ax,bx div cx mov dx,si retcode endsend start","tags":["汇编语言"],"categories":["汇编语言","lab以及课程设计"]},{"title":"CSAPP_datalab","path":"/2023/09/23/CSAPP/lab1/","content":"自己本人只能做出30%，剩下的部分都是借鉴别人的代码而写的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211//1/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~(~x&amp;~y)&amp;~(x&amp;y);&#125;/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return (1&lt;&lt;31);&#125;//2/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; return !(~(x+1)^x)&amp;!!(x+1);&#125;/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int mask = 0xAA + ((0xAA)&lt;&lt;8); mask = mask + (mask&lt;&lt;16); return !((mask&amp;x)^mask);&#125;/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x + 1;&#125;//3/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; int a = !(x&gt;&gt;4 ^ 0x3); int na = ~0xA + 1; int x_b4 = x &amp; 0xF; int b = !!((x_b4 + na) &amp; 0x8000); return a &amp; b;&#125;/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; x = !!x; //x!=0 -&gt; 1 x ==0 -&gt; 0 x = ~x + 1; return (x&amp;y)|(~x&amp;z);&#125;/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int a = (x &gt;&gt; 31)&amp;0x1; int b = (y &gt;&gt; 31)&amp;0x1; int flag1 = (a&amp;~b); //a- b+ int flag2 = (~a&amp;b); //a+ b- int minus = (y + (~x+1)) &gt;&gt; 31; //x&lt;=y &lt;-&gt; minus=0 return flag1 | (!flag2 &amp; !minus);&#125;//4/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; return ((x|(~x+1))&gt;&gt;31)+1;&#125;/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) &#123; int b16, b8, b4, b2, b1, b0; int flag = x&gt;&gt;31; x = (~flag&amp;x)|(flag&amp;~x); //x若为负数，则取反 b16 = !!(x&gt;&gt;16)&lt;&lt;4; x &gt;&gt;= b16; b8 = !!(x&gt;&gt;8)&lt;&lt;3; x &gt;&gt;= b8; b4 = !!(x&gt;&gt;4)&lt;&lt;2; x &gt;&gt;= b4; b2 = !!(x&gt;&gt;2)&lt;&lt;1; x &gt;&gt;= b2; b1 = !!(x&gt;&gt;1); x &gt;&gt;= b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1;&#125;//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) &#123; int exp = (0x7f800000 &amp; uf)&gt;&gt;23; int sign = uf &amp; (1&lt;&lt;31); if(exp == 255) return uf; if(exp == 0) return (uf&lt;&lt;1)|sign; exp++; if(exp==255) return 0x7f800000|(uf&amp;0x807fffff); return (exp&lt;&lt;23)|(uf&amp;0x807fffff);&#125;/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) &#123; unsigned exp = (0x7f800000 &amp; uf)&gt;&gt;23; int sign = (uf&gt;&gt;31)&amp;0x1; unsigned frac = uf&amp;0x7fffff; int E = exp - 127; if(E &lt; 0) return 0; if(E &gt;= 31) return 0x80000000u; frac |= 1&lt;&lt;23; if(E &lt; 23) frac &gt;&gt;= (23-E); else frac &lt;&lt;= (E-23); if(sign) return -frac; else return frac;&#125;/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) &#123; if(x&gt;127) return (0xff)&lt;&lt;23; if(x&lt;-149) return 0; if(x&gt;=-126)&#123; int exp = x + 127; return (exp&lt;&lt;23); &#125; else&#123; int t = x + 149; return (1&lt;&lt;t); &#125; return 2;&#125;","tags":["CSAPP","lab"],"categories":["CSAPP","lab"]}]