[{"title":"JSTL标签库","path":"/2024/03/16/JSTL/","content":"为什么要使用JSTL？ JSTL全称为JSP Standard Tag Library。它是一个JSP的标准标签库，目的在于取代在JSP中的那些java代码，以一种标签的形式来写Java代码，这会使得JSP代码更像HTML(因为都是标签)。 但本质依旧是Java代码，JSP翻译引擎会将JSP代码翻译为java代码的。","tags":["JavaWeb"]},{"title":"《C++ Primer》第二章 变量和基本类型","path":"/2023/12/13/c++primer/第二章/","content":"2.1 基本内置类型 C++ 的基本内置类型是 ==算数类型==和==void类型== 2.1.1 算数类型 C++语言规定 sizeof(int) &gt;= sizeof(short), sizeof(long) &gt;= sizeof(int), sizeof(long long) &gt;= sizeof(long) 除了布尔型和扩展的字符集，其他算术类型都有有符号和无符号之分。它们在机器中都是以二进制存储的，只是对于位的解释不同。 内置类型的机器实现：可寻址的最小内存块称为“字节”，存储的基本单元称为“字”。一个字节对应一个地址，不同内置类型占用的字节数不同，值会放在对应的地址空间(如 2个字节，4个字节)中。 字符类型也属于算数类型，如char和扩展字符集(wchar_t, char16_t, char32_t) 2.1.2 类型转换 当我们赋值给带符号类型一个超过它容量的数，这种行为是未定义的。此时，程序可能继续工作，可能崩溃，也可能生成垃圾数据。 当一个算数表达式里面既有有符号数也有无符号数，那么有符号数会转化为无符号数，也就是改变对二进制位的解释。 处理带符号数和无符号数的时候，把它们看作二进制数进行处理。 2.1.3 字面值常量 整型和浮点型字面值 一般的写法如 20, 30 是十进制字面值，类型为int，long，long long中可以容纳该数的最小的一个。 以0开头的一串数如 020 是八进制字面值，类型为int, unsinged int, long, unsigned long, long long, unsigned long long中能容纳该数的最小的一个。 以0x开头的如 0x20 是十六进制字面值，类型同八进制 浮点数 如 3.14，3.14E0, 0. , 0e0, .001 ，类型默认是double 字符和字符串字面值 'A'是字符字面值 \"Hello World\" 是字符串字面值，它的结尾多了一个\\0，那是编译器自动加的 指定字面值的类型 给 数字/字符/字符串 加前缀或者后缀，可以修改该 数字/字符/字符串 的默认类型。 如 42ULL，1E-3F 布尔字面值 true false 指针字面值 nullptr 转义序列 \\x后面跟的是十六进制 \\后面跟的是八进制 可以将数字转化为对应的字符，得到同样的效果。 如 \\12 \\xA， 其中 的ascii码的十进制是10。 2.2 变量 本书中，变量 也称作 对象 ==初始化和赋值的区别==：初始化是创建变量的同时给它一个值，而赋值是指用一个新的值来覆盖旧值 列表初始化 采用花括号初始化变量，如 int a&#123;0&#125;，int a = &#123;0&#125; 但是如果把一个值给变量的时候会把让值损失信息的话，是不能够这样的。如 int a&#123;3.14&#125; 默认初始化 如果定义变量的时候没有指定初始值，那么它会被默认初始化。 2.3 复合类型 2.4 const限定符 2.5 处理类型 2.6 自定义数据结构","tags":["C++","C++Primer"]},{"title":"《C++ Primer》第一章 开始","path":"/2023/12/13/c++primer/第一章/","content":"1.1 编写一个简单的C++程序 ==一个函数的四部分==：函数类型，函数名，函数参数，函数体。 ==类型==：数据都保存在变量中，每个变量都有自己的类型。 ==编译一个C++文件==(如test.cpp)：g++ -o test test.cpp 这样会输出 test.exe 1.2 初识输入输出 标准库具有四个IO对象：cout, cin, cerr, clog &lt;&lt;运算符接受两个运算对象，运算后返回左边对象。 endl是一个操纵符，写入endl是为了结束当前行，并将设备关联的缓冲区中的内容输入到设备中。 使用的cout等都是标准命名空间std里的名字，需要用作用域运算符::显式的指明 如 std::cout 1.3 注释简介 两种注释，一种是单行注释，另一种是多行注释。 单行注释 1std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl; // 输出Hello World 多行注释 12345std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;/* 输出 * Hello * World */ 1.4 控制流 控制流指的是控制程序执行的流程或顺序。常见的控制流语句有 顺序语句，循环语句，判断语句，跳转语句。 这一小节介绍了 while 和 for 这两个循环语句 和 if 这个判断语句。考虑循环语句的时候，考虑循环的开始和结束，以及中间每一步是怎么走的。 还介绍了如何读取数量不定的输入数据。 1while(std::cin &gt;&gt; a) 当读入文件结束符(windows下是Ctrl+Z)时，cin被判定无效，退出循环。 1.5 类简介 一个类定义了一个类型，以及与之关联的一系列操作。数据结构 也具有类似的含义。 类和对象之间的关系是抽象和具体。 写类的时候将类看作是一个普通的对象有助于理解。 成员函数相当于一个接口，使得能够访问类的变量或者和让其他变量和类的变量进行比较。","tags":["C++","C++Primer"]},{"title":"roop——人工换脸工具","path":"/2023/12/04/人工智能/roop——AI换脸工具/","content":"roop安装 github链接：roop 按照官网文档使用说明直接安装即可。 几点说明 使用anaconda包管理工具，可以建立多个环境，使得每个环境里的包的版本和python的版本可以不同。 若使用CUDA进行加速，下载CUDA和cuDNN的时候按照roop官方文档的版本进行安装，因为安装的包中有一个叫做onnxruntime的包，这个包的使用文档里有兼容的CUDA和cuDNN版本。链接: onnxruntime 简单来说就是下载 CUDA Toolkit 11.8 和 cuDNN v8.5.0 for Cuda 11.x, 后者下载需要登陆Nvidia账号，且进入速度较慢，耐心等待。 收获的经验 严格阅读官方文档安装说明，按照官方文档指定的包进行安装，不要自己想当然的安装最新版本的包，这样会导致包和包之间的不匹配。 即时按照官网文档安装了，运行时依旧可能出错，按照错误从上往下修改，每次修改了一个错误之后，再运行一遍查看是否仍旧有错，因为可能下面的错误是由于上面的错误导致的。 使用效果体验 照片换脸效果还可以，但是视频换脸效果一般。","tags":["人工智能，娱乐"]},{"title":"课程设计2","path":"/2023/10/29/汇编语言/课程设计2/","content":"遇到的问题 安装到磁盘里的代码是不能直接通过 table[bx] 这样直接利用下标的方式询问，必须采用位移差和绝对位置的方式。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352assume cs:codecode segmentstart: call copyleadToFD call copybootToFD mov ax,4c00h int 21h; lead 是将 0面0道2扇区 的内容放在 0000:7E00 处, 然后从此开始启动 bootlead: mov ax,cs mov es,ax mov bx,7E00H mov dh,0 mov ch,0 mov cl,2 mov al,2 mov dl,0 mov ah,2 int 13h mov ax,0 push ax mov ax,7E00H push ax retfcopyleadToFD: mov bx,cs mov es,bx mov bx,offset lead mov dh,0 mov ch,0 mov cl,1 mov al,1 mov dl,0 mov ah,3 int 13h retcopybootToFD: mov bx,cs mov es,bx mov bx,offset boot mov dh,0 mov ch,0 mov cl,2 mov al,2 mov dl,0 mov ah,3 int 13h retboot: jmp near ptr boot_start MENU_1 db &#x27;Welcome to System of Mr.Jin&#x27;,0 MENU_2 db &#x27;(1) Reset PC&#x27;,0 MENU_3 db &#x27;(2) Start System&#x27;,0 MENU_4 db &#x27;(3) ShowClock&#x27;,0 MENU_5 db &#x27;(4) Set Clock&#x27;,0 MENU_6 db &#x27;Please Enter Your Choose(1~4)&#x27;,0 date db &#x27;YY/MM/DD HH:MM:SS&#x27;,0 cmos db 9,8,7,4,2,0 ADDRESS dw MENU_1 - boot + 7e00h dw MENU_2 - boot + 7e00h dw MENU_3 - boot + 7e00h dw MENU_4 - boot + 7e00h dw MENU_5 - boot + 7e00h dw MENU_6 - boot + 7e00hboot_start: call clearScreen call resetRegister call showMenu call getChoice mov ax,4c00h int 21hclearScreen: mov bx,0b800h mov es,bx mov di,0 mov cx,2000 s1: mov word ptr es:[di],0700H add di,2 loop s1 retresetRegister: mov bp,0 mov bx,cs mov ds,bx mov bx,0b800h mov es,bxshowMenu: mov di,160*8+2*25 mov bx,ADDRESS - boot + 7e00h mov cx,6 s: mov si,ds:[bx] call showLine add bx,2 add di,160 loop s ret showLine: push di push si showLineStart: mov al,ds:[si] cmp al,0 je showLineOver mov es:[di],al inc si add di,2 jmp showLineStart showLineOver: pop si pop di retgetChoice: mov ah,0 int 16h cmp al,&#x27;1&#x27; je option_1 cmp al,&#x27;2&#x27; je option_2 cmp al,&#x27;3&#x27; je option_3 cmp al,&#x27;4&#x27; je option_4option_1: call resetPCoption_2: call startSystemoption_3: call clock jmp boot_startoption_4: call setClock jmp boot_startresetPC: mov bx,0FFFFH push bx mov bx,0 push bx retfstartSystem: mov bx,0 mov es,bx mov bx,7c00h mov dh,0 mov ch,0 mov cl,1 mov al,1 mov dl,80h mov ah,2 int 13h mov bx,0 push bx mov bx,7c00h push bx retfclock: call clearScreen loop_clock: mov di,cmos - boot + 7e00h mov si,date - boot + 7e00h call showTime mov ah,1 int 16h jz loop_clock ; 当键盘缓冲区有值 -&gt; zf=0 -&gt; 不跳转 changeColorOrReturn: cmp ah,3BH je changeShowColor cmp al,1BH je returnToMenu cmp al,0 jne mark jmp loop_clockchangeShowColor: mov cx,2000 mov bx,1 s3: add byte ptr es:[bx],1 or byte ptr es:[bx],00001000B ;高亮不闪烁设置 and byte ptr es:[bx],10001111B ;背景一直为黑色 add bx,2 loop s3 mark: call clearKeyboardBuffer jmp loop_clockreturnToMenu: retshowTime: mov cx,6 s2: mov al,ds:[di] out 70H,al in al,71H mov ah,al push cx mov cl,4 shr ah,cl pop cx and al,00001111B add ah,30H add al,30H mov ds:[si],ah mov ds:[si+1],al add si,3 inc di loop s2 mov si,date - boot + 7e00h mov di,160*10+2*30 call showLine retclearKeyboardBuffer: mov ah,1 int 16H jz clearKeyboardBufferOver mov ah,0 int 16H jmp clearKeyboardBuffer clearKeyboardBufferOver: retsetClock: call getstr call setCMOSRAM retgetstr: call clearScreen mov si,date - boot + 7e00h getstrs: mov ah,0 int 16H cmp al,20h jb nochar call charpush call charshow jmp getstrs nochar: cmp ah,0EH je backspace cmp ah,1CH je enter jmp getstrs backspace: call charpop call charshow jmp getstrs enter: ret charpush: mov bx,bp mov ds:[si+bx],al inc bp ret charpop: cmp bp,0 je sret dec bp ret charshow: mov dh,10 mov dl,30 mov al,160 mov ah,0 mul dh mov di,ax add dl,dl mov dh,0 add di,dx mov bx,0 charshows: cmp bx,bp jne noempty mov byte ptr es:[di],&#x27; &#x27; ret noempty: mov al,ds:[si+bx] mov es:[di],al inc bx add di,2 jmp charshows sret: retsetCMOSRAM: mov si,cmos - boot + 7e00h mov di,date - boot + 7e00h mov cx,6 s4: mov bx, ds:[di] sub bx,3030h push cx mov cl,4 shl bl,cl and bh,00001111B or bh,bl pop cx mov al,ds:[si] out 70h,al mov al,bl out 71h,al inc si add di,3 loop s4 retcode endsend start","tags":["汇编语言"]},{"title":"vmware内安装Win98","path":"/2023/10/26/vmware/","content":"vmware新建虚拟机 安装客户机操作系统 选择 稍后安装操作系统 虚拟机内存 1G 网络选择 选择桥接网络 磁盘 类型：由于在现在的平台上无法直接安装win98，会提示安装程序执行了非法操作。有一种简单的方法就是把磁盘类型改为SATA。 大小：8G win98安装 win98下载 下载链接 在创建的虚拟机的设置中导入镜像 选择CD-ROM启动，再选择Start Windows 98 Setup from CD-ROM。 选择 Configure unallocated disk space. 由于8G磁盘大小足够，所以选择 无需更大的硬盘支持。 按照提示一步一步安装即可。 win98序列号：WHWGP-XDR8Y-GR9X3-863RP-67J2T vmware tools安装 软盘创建 参考链接：https://www.syrr.cn/post/618747.html?action=onClick","tags":["vmware","操作系统，汇编语言"]},{"title":"王爽《汇编语言》lab17","path":"/2023/10/21/汇编语言/lab17/","content":"题目 安装一个新的int7中断例程，实现通过逻辑扇区号对软盘进行读写。 遇到的问题以及解决方法 在我的dosbox下，不能对软盘进行读写，也就是mov dl,0不行，但可以对硬盘进行读写，也就是mov dl,80h可以。 收获 要注意栈push和pop的时机，比如对al和ah设置好内容了之后，再pop ax会使得设置无效。需要调整顺序。 代码 install.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset write2disk mov ax,0 mov es,ax mov di,200h mov cx,offset write2diskEnd - offset write2disk cld rep movsb cli mov es:[7ch*4],200h mov es:[7ch*4+2],0 sti mov ax,4c00h int 21hwrite2disk: ; dx 是传入的逻辑扇区号，es:bx为操作内存 cmp ah,1 ja sret push bx push ax mov bx,1440 mov ax,dx mov dx,0 div bx ; 得到 int(逻辑扇区号/1440) 存放在ax内，得到 rem(逻辑扇区号/1440) 存放在dx内 mov si,ax mov bh,0 mov bl,18 mov ax,dx div bl ; 得到 int(rem(逻辑扇区号/1440)/18) 存放在al内，得到 rem(rem(逻辑扇区号/1440)/18) 存放在ah内 ; 设置参数 mov dx,si mov dh,dl ; 面号 mov ch,al mov cl,ah inc cl pop ax pop bx mov al,1 mov dl,80h add ah,2 int 13hsret: iretwrite2diskEnd: nopcode endsend start test.asm 123456789101112131415assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov bx,0 mov ah,0 mov dx,0 int 7ch mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab16","path":"/2023/10/20/汇编语言/lab16/","content":"要求 安装一个新的int7ch中断例程，为显示输出提供如下功能子程序。 (1)清屏： (2)设置前景色； (3)设置背景色： (4)向上滚动一行。 入口参数说明如下。 (1)用ah寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行； (2)对于1、2号功能，用al传送颜色值，(al)∈{0,1,2,3,4,5,6,7}。 需要思考的问题 安装好程序之后，如何寻址到对应的子程序？ 解答：当安装好程序之后，test.asm中的int 7ch会调用该中断程序，那么此时CS:IP设置为0000:0200 执行到call word ptr cs:[202h+bx]时，会寻址到 sub1 - setScreen + 200H，也就是sub1程序。 但是call word ptr table[bx]并不能正确寻址到sub1程序，并且table dw sub1 - setScreen + 200H不能写成table dw sub1， 本人猜测是因为该程序放在0:200处，不是在定义的代码段内，所以并不能只通过 table 和 sub1 正确寻址，需要通过位移。 （jmp short set 的机器码也是包含位移） 代码 install.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,200h mov ax,cs mov ds,ax mov si,offset setScreen mov cx,offset setScreenEnd - offset setScreen cld rep movsb mov es:[7ch*4],200h mov es:[7ch*4+2],0 ; test ; mov ah,3 ; mov al,4 ; int 7ch mov ax,4c00h int 21hsetScreen: jmp short set table dw sub1 - setScreen + 200H, sub2 - setScreen + 200H, sub3 - setScreen + 200H, sub4 - setScreen + 200H set: push bx cmp ah,3 ja sret mov bl,ah mov bh,0 add bx,bx call word ptr cs:[202h+bx] ; call word ptr table[bx] sret: pop bx iretsub1: push bx push cx push es mov bx,0b800h mov es,bx mov bx,0 mov cx,2000sub1s: mov byte ptr es:[bx],&#x27; &#x27; add bx,2 loop sub1s pop es pop cx pop bx retsub2: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cx,2000sub2s: and byte ptr es:[bx],11111000B or es:[bx],al add bx,2 loop sub2s pop es pop cx pop bx retsub3: push bx push cx push es mov bx,0b800h mov es,bx mov bx,1 mov cl,4 shl al,cl mov cx,2000sub3s: and byte ptr es:[bx],10001111B or es:[bx],al add bx,2 loop sub3s pop es pop cx pop bx retsub4: push cx push si push di push es push ds mov si,0b800h mov ds,si mov es,si mov si,160 mov di,0 cld mov cx,24sub4s: push cx mov cx,160 rep movsb pop cx loop sub4s mov cx,80 mov si,0sub4s1: mov byte ptr [160*24+si],&#x27; &#x27; add si,2 loop sub4s1 pop ds pop es pop di pop si pop cx retsetScreenEnd: nopcode endsend start test.asm 1234567891011assume cs:codecode segmentstart: mov ah,1 mov al,2 int 7ch mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab15","path":"/2023/10/20/汇编语言/lab15/","content":"要求 安装一个新的int 9中断例程，功能：在DOS下，按下“A”键后，除非不再松开，如果松开，就显示满屏幕的“A”,其他的键照常处理。 代码 install.asm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset int9 mov ax,0 mov es,ax mov di,204H mov cx,offset int9end-offset int9 cld rep movsb ; 把原int9程序的入口放在 0:200 ~ 0:203 中 mov ax,es:[9*4] mov es:[200H],ax mov ax,es:[9*4+2] mov es:[202H],ax ; 把现int9程序的入口放在 0:9*4 ~ 0:9*4+3 中，把int9程序放在以 0:204H 开始的地址中 mov word ptr es:[9*4],204H mov word ptr es:[9*4+2],0 mov ax,4c00h int 21hint9: push ax pushf call dword ptr cs:[200H] ;调用BIOS的int9中断例程，处理其他硬件细节 in al,60h cmp al,9EH jne int9retshowAllScreenA: mov ax,0b800h mov es,ax mov bx,0 mov cx,2000 s2: mov byte ptr es:[bx],&#x27;A&#x27; add bx,2 loop s2int9ret: pop ax iretint9end: nop code endsend start test.asm 12345678910111213141516171819202122assume cs:codecode segmentstart:delay: mov dx,100 mov ax,0s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1mov ax,4c00hint 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab14","path":"/2023/10/19/汇编语言/lab14/","content":"读取BIOS RAM中的内容。写入到显存内 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667assume cs:codedata segment db 9,8,7,4,2,0data endscode segmentstart: mov ax,data mov ds,ax mov dx,0b800H mov es,dx mov cx,6 mov si,0 mov di,160*0+2*0s: mov al,[si] out 70H,al in al,71H push cx mov ah,al mov cl,4 shr ah,cl pop cx and al,00001111B add ah,30H add al,30H call show add di,4 cmp si,0 je showSlash cmp si,1 je showSlash cmp si,2 je showSpace cmp si,3 je showColon cmp si,4 je showColonback: add di,2 inc si loop s mov ax,4c00h int 21hshow: mov byte ptr es:[di],ah mov byte ptr es:[di+2],al retshowSlash: mov byte ptr es:[di],47 jmp backshowSpace: mov byte ptr es:[di],0 jmp backshowColon: mov byte ptr es:[di],58 jmp backcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab13","path":"/2023/10/19/汇编语言/lab13/","content":"(1)编写并安装int 7ch中断例程，功能为显示一个用0结束的字符串 中断例程安装在0:200处。 参数：(dh)=行号，(dl)=列号，(cl)=颜色，ds:si指向字符串首地址。 install.asm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,200H mov ax,cs mov ds,ax mov si,offset showStr mov cx,offset showStrEnd-offset showStr cld rep movsb mov ax,0 mov es,ax mov word ptr es:[7cH*4],200h mov word ptr es:[7cH*4+2],0 mov ax,4c00h int 21h; -------; showStr是在对应的行列显示字符; -------showStr: mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax ;di为计算出来的偏移地址 mov bl,cl mov cx,0 s: mov cl,[si] jcxz ok mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 inc si jmp short s ok: iretshowStrEnd: nopcode endsend start test.asm 1234567891011121314151617181920assume cs:codedata segment db &quot;welcome to masm!&quot;, 0data endscode segmentstart: mov dh,10 ;行号 mov dl,10 ;列号 mov cl,2 mov ax,data mov ds,ax mov si,0 int 7ch mov ax,4c00h int 21hcode endsend start (2)编写并安装int7ch中断例程，功能为完成loop指令的功能 参数：(cx)=循环次数，(bx)=位移 在屏幕中间显示80个'!' install.asm 12345678910111213141516171819202122232425262728293031323334assume cs:codecode segmentstart: mov ax,0 mov es,ax mov di,200h mov ax,cs mov ds,ax mov si,offset emuLoop mov cx,offset emuLoopEnd-emuLoop cld rep movsb mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21hemuLoop: jcxz ok pop ax add ax,bx push ax dec cx ok: iretemuLoopEnd: nopcode endsend start test.asm 12345678910111213141516171819assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s-offset se mov cx,80s: mov byte ptr es:[di],&#x27;!&#x27; add di,2 int 7chse: nop mov ax,4c00h int 21hcode endsend start (3)下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。 1234567891011121314151617181920212223242526272829303132assume cs:codecode segment s1: db &#x27;Good,better,best,&#x27;, &#x27;$&#x27; s2: db &#x27;Never let it rest,&#x27;, &#x27;$&#x27; s3: db &#x27;Till good is better,&#x27;, &#x27;$&#x27; s4: db &#x27;And better,best.&#x27;, &#x27;$&#x27; s: dw offset s1,offset s2,offset s3,offset s4 row:db 2,4,6,8start: mov ax,cs mov ds,ax mov bx,offset s mov si,offset row mov cx,4ok: mov bh,0 mov dh,[si] mov dl,0 mov ah,2 int 10h ;设置光标位置 mov dx,[bx] mov ah,9 int 21h ;显示 ds:dx 开始的字符，到 $ 停止。 inc si add bx,2 loop ok mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》lab12","path":"/2023/10/15/汇编语言/lab12/","content":"实验要求：编写0号中断的处理程序，使得在除法溢出发生时，在屏幕中间显示字符串\"divede error\"，然后返回到DOS 主要考察 CPU是如何执行内中断的？ 简单来讲，CPU会根据中断信息获取中断类型码N，然后在中断向量表中根据 N 计算中断程序的入口地址，即 \\((IP) = (N*4), (CS) = (N*4+2)\\), 设置好CS:IP，也就是执行代码的位置, 开始执行即可。 如何设计代码？ 将中断程序的代码放入0000:0200 ~ 0000:02FF中，之后在中断向量表中设置好中断程序的入口地址即可。 &gt; 除法溢出的中断类型码是 0 代码 install.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051assume cs:codecode segment start: mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov ax,cs mov ds,ax mov si, offset do0 ;设置ds:si指向原地址 mov cx, offset do0end-offset do0 cld rep movsb mov ax,0 mov es,ax mov word ptr es:[0], 200H mov word ptr es:[2], 0H mov ax,4c00h int 21hdo0: jmp short do0start db &quot;divide error!&quot; do0start: mov ax,cs mov ds,ax mov si,0202h ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,160*0+2*0 ;设置es:di指向显存空间的中间位置 mov cx,0dh ;设置字符串长度s: mov al, ds:[si] mov ah, 2 ;设置为绿色 mov es:[di], ax inc si add di,2 loop s iretdo0end: nopcode endsend start test.asm 123456789assume cs:codecode segmentstart: int 0h mov ax,4c00h int 21hcode endsend start","tags":["汇编语言"]},{"title":"王爽《汇编语言》 lab11","path":"/2023/10/11/汇编语言/lab11/","content":"主要考察了cmp指令和je等条件转移指令的应用。 1234567891011121314151617181920212223242526272829303132assume cs:codesgdatasg segment db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;, 0datasg endscodesg segmentbegin: mov ax,datasg mov ds,ax call lettercok: mov ax,4c00h int 21hletterc: mov si,0 mov cx,0 s: mov al,[si] mov cl,al jcxz ok cmp al,97 jb exit cmp al,122 ja exit and al,11011111B mov [si],al exit: inc si jmp short scodesg endsend begin","tags":["汇编语言"]},{"title":"王爽《汇编语言》课程设计1","path":"/2023/10/08/汇编语言/课程设计1/","content":"实验要求：显示图片所示的内容 瑕疵以及解决方法 瑕疵：显示数据的时候最后一行往往不能正常显示。 解决方法：多添加了一行无用数据，使得题目所给数据能够正常显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200; 不知道为什么显示最后一行的时候会出错, 所以我多加了一行数据assume cs:codesgdata segmentdb&#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;db&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;db&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;,&#x27;0000&#x27;;以上是表示21年的21个字符串dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000,0 ;以上是表示21年公司总收入的21个dword型数据dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226dw 11542,14430,15257,17800,1;以上是表示21年公司雇员人数的21个word型数据data ends;将数据放到一张表里面table segmentdb 22 dup(&#x27;year summ ne ??&#x27;)table ends; 用来临时存放倒序的数digit segment db 32 dup(0)digit endsstacksg segment dw 8 dup (0)stacksg endscodesg segmentstart: mov ax,stacksg mov ss,ax mov sp,32 mov ax,table mov ds,ax\tmov ax,data\tmov es,ax\tmov si,0\tmov di,88\tmov bp,176\tmov bx,0\tmov cx,22 call dtb ; 经过测试，能成功将数据显示到table段中！ call far ptr vis_number mov ax,4c00h int 21hdtb: ; dtb将数据都放在table里面 s1: mov ax, es:[si] ;利用ax作为中转站 mov [bx+0], ax mov ax, es:[si+2] mov [bx+2], ax mov byte ptr [bx+4], 20h mov ax, es:[di] mov [bx+5], ax mov ax, es:[di+2] mov [bx+7], ax mov byte ptr [bx+9], 20h mov ax, es:[bp] mov [bx+10], ax mov byte ptr [bx+12], 20h mov ax, [bx+5] mov dx, [bx+7] div word ptr [bx+10] mov [bx+13], ax mov byte ptr [bx+15], 20h add bx,16 add si,4 add di,4 add bp,2 loop s1 retvis_number: mov bx,0B800H mov es,bx mov cx,22 mov si,0 ; ds:si 指向table mov di,0 ; es:di 指向显存位置 sr: push cx call far ptr paint ;把这一行都变为空白 mov cx,4 mov bp,cx s4: mov al,[si] mov es:[di],al inc si add di,2 loop s4 call far ptr set_begin inc si mov ax,[si] mov dx,[si+2] call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,5 mov ax,[si] mov dx,0 call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,3 mov ax,[si] mov dx,0 call far ptr dtoc pop di call far ptr show_str call far ptr set_begin pop ds pop si add si,3 add di,80 pop cx loop sr retfpaint: mov cx,40 s2: mov es:[di],0 mov es:[di+1],7 add di,2 loop s2 sub di,80 retfdtoc: pop bx ; dtoc 的 ip pop cx ; dtoc 的 cs push si push ds push di push cx push bx mov bx,digit mov ds,bx mov di,0 mov bp,0 s: mov cx,10 mov bx,ax ; bx存放L(低16位) mov ax,dx mov dx,0 div cx ; int(H/N)在ax中，rem(H/N)在dx中 mov si,ax ; si存放int(H/N) mov ax,bx div cx ; 余数在dx中 add dl,30H mov [di],dl mov cx,ax inc bp add cx,si ; 算商是否为0，(cx) = (si) + (ax) jcxz ps ;当商是0的时候退出 inc di mov dx,si jmp s ps: retfshow_str: mov cx,bp mov ax,bp dec bp mov si,bp inc bp s5: mov al,[si] mov es:[di],al dec si add di,2 loop s5 retfset_begin: sub di,bp sub di,bp add di,20 retfcodesg endsend start","tags":["汇编语言"]},{"title":"博客搭建","path":"/2023/10/06/博客搭建/","content":"博客搭建 对博客的优化 渲染latex","tags":["博客搭建"]},{"title":"王爽《汇编语言》lab10","path":"/2023/10/06/汇编语言/lab10/","content":"往显存里面写东西，使得显示器能立马显示所写的内容 下面是lab10的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103assume cs:codedata segment db 10 dup (0)data endscode segmentstart: ; test for subprogram 1 ; mov dh,13 ; mov dl,0 ; mov cl,2 ; mov ax,data ; mov ds,ax ; mov si,0 ; call show_str ; test for subprogram 2 ; mov ax,4240H ; mov dx,000FH ; mov cx,0AH ; call divdw ;test for subprogram 3 mov ax,12466 mov bx,data mov ds,bx mov si,0 mov bp,0 ;用来存放有几位 call dtoc ok2:mov dh,13 mov dl,0 mov cl,2 mov si,0 call show_str2 ok: mov ax,4c00h int 21hshow_str: mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax mov bl,cl mov cx,0 s: mov cl,[si] jcxz ok mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 inc si jmp short sshow_str2: ;搭配dtoc使用，实现反向输出 mov ax,0B800H ;计算行和列 在 显存中的地址 mov es,ax mov al,dh mov bl,0A0H mul bl mov di,ax mov al,dl mov bl,2H mul bl add di,ax mov bl,cl mov cx,bp dec bp mov si,bp s2: mov al,[si] mov es:[di],al mov es:[di+1],bl add di,2 dec si dec cx jcxz ok jmp short s2 dtoc: mov bx,10 mov dx,0 ;不写这句话程序运行不了，应该是后面用到了dl，所以需要将dx先置0 s1: div bx add dl,30H ;dl存放余数 mov [si],dl inc bp mov dl,0 mov cx,ax jcxz ok2 inc si jmp short s1divdw: mov bx,ax ;bx存放L mov ax,dx mov dx,0 div cx ;得到 int(H/N)在ax中 和 rem(H/N)在dx中 mov si,ax ;si存放int(H/N) mov ax,bx div cx mov dx,si retcode endsend start","tags":["汇编语言"]},{"title":"CSAPP_datalab","path":"/2023/09/23/CMU 15-213(CSAPP)/lab1/","content":"自己本人只能做出30%，剩下的部分都是借鉴别人的代码而写的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211//1/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~(~x&amp;~y)&amp;~(x&amp;y);&#125;/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return (1&lt;&lt;31);&#125;//2/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; return !(~(x+1)^x)&amp;!!(x+1);&#125;/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int mask = 0xAA + ((0xAA)&lt;&lt;8); mask = mask + (mask&lt;&lt;16); return !((mask&amp;x)^mask);&#125;/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x + 1;&#125;//3/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; int a = !(x&gt;&gt;4 ^ 0x3); int na = ~0xA + 1; int x_b4 = x &amp; 0xF; int b = !!((x_b4 + na) &amp; 0x8000); return a &amp; b;&#125;/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; x = !!x; //x!=0 -&gt; 1 x ==0 -&gt; 0 x = ~x + 1; return (x&amp;y)|(~x&amp;z);&#125;/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int a = (x &gt;&gt; 31)&amp;0x1; int b = (y &gt;&gt; 31)&amp;0x1; int flag1 = (a&amp;~b); //a- b+ int flag2 = (~a&amp;b); //a+ b- int minus = (y + (~x+1)) &gt;&gt; 31; //x&lt;=y &lt;-&gt; minus=0 return flag1 | (!flag2 &amp; !minus);&#125;//4/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; return ((x|(~x+1))&gt;&gt;31)+1;&#125;/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) &#123; int b16, b8, b4, b2, b1, b0; int flag = x&gt;&gt;31; x = (~flag&amp;x)|(flag&amp;~x); //x若为负数，则取反 b16 = !!(x&gt;&gt;16)&lt;&lt;4; x &gt;&gt;= b16; b8 = !!(x&gt;&gt;8)&lt;&lt;3; x &gt;&gt;= b8; b4 = !!(x&gt;&gt;4)&lt;&lt;2; x &gt;&gt;= b4; b2 = !!(x&gt;&gt;2)&lt;&lt;1; x &gt;&gt;= b2; b1 = !!(x&gt;&gt;1); x &gt;&gt;= b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1;&#125;//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) &#123; int exp = (0x7f800000 &amp; uf)&gt;&gt;23; int sign = uf &amp; (1&lt;&lt;31); if(exp == 255) return uf; if(exp == 0) return (uf&lt;&lt;1)|sign; exp++; if(exp==255) return 0x7f800000|(uf&amp;0x807fffff); return (exp&lt;&lt;23)|(uf&amp;0x807fffff);&#125;/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) &#123; unsigned exp = (0x7f800000 &amp; uf)&gt;&gt;23; int sign = (uf&gt;&gt;31)&amp;0x1; unsigned frac = uf&amp;0x7fffff; int E = exp - 127; if(E &lt; 0) return 0; if(E &gt;= 31) return 0x80000000u; frac |= 1&lt;&lt;23; if(E &lt; 23) frac &gt;&gt;= (23-E); else frac &lt;&lt;= (E-23); if(sign) return -frac; else return frac;&#125;/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) &#123; if(x&gt;127) return (0xff)&lt;&lt;23; if(x&lt;-149) return 0; if(x&gt;=-126)&#123; int exp = x + 127; return (exp&lt;&lt;23); &#125; else&#123; int t = x + 149; return (1&lt;&lt;t); &#125; return 2;&#125;","tags":["CSAPP"],"categories":["CSAPP"]}]